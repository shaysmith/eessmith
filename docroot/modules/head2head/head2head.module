<?php

/**
 * @file
 * Provides HEAD-HEAD upgrade helpers.
 */

use Drupal\Core\Cache\DatabaseBackend;
use Drupal\Core\Cache\DatabaseCacheTagsChecksum;
use Drupal\Core\Database\DatabaseExceptionWrapper;
use Drupal\Core\Database\Database;
use Drupal\Core\Entity\ContentEntityTypeInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Entity\Sql\SqlEntityStorageInterface;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\views\Entity\View;
use Drupal\Component\Utility\SafeMarkup;
use Drupal\user\Entity\Role;
use Symfony\Component\Yaml\Yaml;

/**
 * Converts Taxonomy term reference fields to Entity reference.
 */
function head2head_1847596() {
  // Nothing to do if there are no taxonomy_term_reference fields.
  if (!$field_storage_configs = \Drupal::entityManager()->getStorage('field_storage_config')->loadByProperties(array('type' => 'taxonomy_term_reference'))) {
    return;
  }

  /** @var \Drupal\field\FieldStorageConfigInterface $field_storage */
  // Update the field storage settings.
  foreach ($field_storage_configs as $field_storage) {
    // Since the usual workflow for field storages do not allow changing the
    // field type, we have to work around it in this case.
    $new_field_storage = $field_storage->toArray();
    $new_field_storage['type'] = 'entity_reference';
    $new_field_storage['module'] = 'core';
    $new_field_storage['settings']['target_type'] = 'taxonomy_term';

    $vocabulary_name = $new_field_storage['settings']['allowed_values'][0]['vocabulary'];
    unset($new_field_storage['settings']['allowed_values']);

    $new_field_storage = FieldStorageConfig::create($new_field_storage);
    $new_field_storage->original = $new_field_storage;
    $new_field_storage->enforceIsNew(FALSE);

    $new_field_storage->save();

    // Update the field settings.
    $field_name = $field_storage->getName();
    if (!$fields = \Drupal::entityManager()->getStorage('field_config')->loadByProperties(array('field_name' => $field_name))) {
      continue;
    }

    /** @var \Drupal\field\FieldConfigInterface $field */
    // Update the field settings.
    foreach ($fields as $field) {
      $new_field = $field->toArray();
      $new_field['field_type'] = 'entity_reference';
      $new_field['settings'] = array(
        'handler' => 'default:taxonomy_term',
        'handler_settings' => array(
          'target_bundles' => array($vocabulary_name => $vocabulary_name),
          // Enable auto-create.
          'auto_create' => TRUE,
        ),
      );

      $new_field = FieldConfig::create($new_field);
      $new_field->original = $field;
      $new_field->enforceIsNew(FALSE);
      $new_field->save();

      // Update entity view displays.
      $properties = array(
        'targetEntityType' => $field->getTargetEntityTypeId(),
        'bundle' => $field->getTargetBundle()
      );
      if ($view_displays = \Drupal::entityManager()->getStorage('entity_view_display')->loadByProperties($properties)) {
        foreach ($view_displays as $view_display) {
          if ($component = $view_display->getComponent($field_name)) {
            // Map taxonomy term reference formatters to entity reference ones.
            switch ($component['type']) {
              case 'taxonomy_term_reference_plain':
                $type = 'entity_reference_label';
                $settings = array(
                  'link' => FALSE,
                );
                break;
              case 'taxonomy_term_reference_link':
                $type = 'entity_reference_label';
                $settings = array(
                  'link' => TRUE,
                );
                break;
              case 'taxonomy_term_reference_rss_category':
                $type = 'entity_reference_rss_category';
                $settings = array();
                break;

              default:
                // Unknown type, set to label formatter.
                $type = 'entity_reference_label';
                $settings = [
                  'link' => FALSE,
                ];
                drupal_set_message(SafeMarkup::format('Unknown taxonomy formatter: %type, setting to %target for %name field', ['%type' => $component['type'], '%target' => 'entity_reference_label', '%name' => $field->label()]));
            }

            $view_display->setComponent($field_name, array(
              'type' => $type,
              'settings' => $settings,
            ) + $component)->save();
          }
        }
      }

      // Update entity form displays.
      $properties = array(
        'targetEntityType' => $field->getTargetEntityTypeId(),
        'bundle' => $field->getTargetBundle()
      );
      if ($form_displays = \Drupal::entityManager()->getStorage('entity_form_display')->loadByProperties($properties)) {
        foreach ($form_displays as $form_display) {
          if ($component = $form_display->getComponent($field_name)) {
            $form_display->setComponent($field_name, array(
              'type' => 'entity_reference_autocomplete_tags',
              'settings' => array(
                'match_operator' => 'CONTAINS',
                'size' => '60',
                'placeholder' => '',
              ),
            ) + $component)->save();
          }
        }
      }
    }
  }
}

/**
 * Provides a default value for the 'default_langcode' property of 'system.site'.
 */
function head2head_2457653() {
  $config_factory = \Drupal::configFactory();
  $langcode = $config_factory->get('system.site')->get('langcode');
  $config_factory->getEditable('system.site')->set('default_langcode', $langcode)->save();
}

/**
 * Removes the 'signatures' property of 'user.settings'.
 */
function head2head_1548204() {
  \Drupal::configFactory()->getEditable('user.settings')->clear('signatures')->save();
}

/**
 * Removes the ['settings']['cache']['contexts'] property for block configs.
 */
function head2head_2428805() {
  $config_factory = \Drupal::configFactory();
  foreach ($config_factory->listAll('block.block.') as $block_config_name) {
    $block = $config_factory->getEditable($block_config_name);
    $settings = $block->get('settings');
    if (isset($settings['cache']) && isset($settings['cache']['contexts'])) {
      unset($settings['cache']['contexts']);
    }
    $block->set('settings', $settings);
    $block->save();
  }
}

/**
 * Removes the 'cache.page.use_internal' setting from 'system.performance' and
 * enable the page_cache module if needed.
 */
function head2head_2368987() {
  $config_factory = \Drupal::configFactory();
  $use_page_cache = $config_factory->get('system.performance')->get('cache.page.use_internal');
  if ($use_page_cache) {
    \Drupal::service('module_installer')->install(array('page_cache'));
  }
  $config_factory->getEditable('system.performance')->clear('cache.page.use_internal')->save();
}

/**
 * Updates entity reference field config entities to the new value needed for
 * the 'handler' setting.
 */
function head2head_2436835() {
  if (!$field_configs = \Drupal::entityManager()->getStorage('field_config')->loadByProperties(array('field_type' => 'entity_reference'))) {
    return;
  }

  // Loop over the field config entities and update the 'handler' setting. The
  // code is the same as entity_reference_field_config_presave() but it is
  // safer to inline it in case that function is moved/renamed.
  /** @var \Drupal\Core\Field\FieldConfigInterface $field */
  foreach ($field_configs as $field) {
    if ($field->isSyncing()) {
      // Don't change anything during a configuration sync.
      return;
    }

    $target_type = $field->getFieldStorageDefinition()->getSetting('target_type');
    $selection_manager = \Drupal::service('plugin.manager.entity_reference_selection');
    list($current_handler) = explode(':', $field->getSetting('handler'), 2);
    if (method_exists($field, 'setSetting')) {
      // Update is running since this method has been added to core.
      $field->setSetting('handler', $selection_manager->getPluginId($target_type, $current_handler));
    }
    else {
      $field->settings['handler'] = $selection_manager->getPluginId($target_type, $current_handler);
    }
    $field->save();
  }
}

/**
 * Add the langcode field to a variety of entity base tables.
 */
function head2head_2431329() {
  $entity_manager = \Drupal::entityManager();
  foreach ($entity_manager->getDefinitions() as $entity_type_id => $entity_type) {
    if ($entity_type instanceof ContentEntityTypeInterface && $entity_type->getDataTable() && $entity_type->hasKey('langcode')) {
      if ($base_table = $entity_type->getBaseTable()) {
        if (!db_field_exists($base_table, 'langcode')) {
          $schema = [
            // This will be updated to varchar_ascii by subsequent update hooks.
            'type' => 'varchar',
            'length' => 12,
          ];
          db_add_field($base_table, 'langcode', $schema);

          // Set values based on field data. `db_update()` doesn't implement any
          // join interfaces, so `db_query()` must be used.
          $data_table = $entity_type->getDataTable();
          $field = $entity_type->getKey('revision');
          $data_langcode_field = $entity_type->getKey('langcode');
          db_query("UPDATE {" . $base_table . "} bt INNER JOIN {" . $data_table . "} dt ON (bt.$field = dt.$field AND default_langcode = 1) SET bt.langcode = dt.$data_langcode_field");

          // Set NOT NULL.
          try {
            $schema['not null'] = TRUE;
            db_change_field($base_table, 'langcode', 'langcode', $schema);
          }
          catch (DatabaseExceptionWrapper $e) {
            $language_manager = \Drupal::languageManager();
            $default_langcode = $language_manager->getDefaultLanguage()->getId();
            drupal_set_message(SafeMarkup::format('Setting %table.langcode to default langcode (%langcode) due to NULL values in field data table.', ['%table' => $base_table, '%langcode' => $default_langcode]), 'warning');
            db_query("UPDATE {" . $base_table . "} SET langcode=:langcode WHERE langcode IS NULL", [':langcode' => $default_langcode]);
            $schema['not null'] = TRUE;
            db_change_field($base_table, 'langcode', 'langcode', $schema);
          }
        }
      }
    }
  }
}

/**
 * Set the admin role flag.
 */
function head2head_2435075() {
  $user_settings = \Drupal::configFactory()->getEditable('user.settings');
  if ($admin_role_id = $user_settings->get('admin_role')) {
    $role = Role::load($admin_role_id);
    $role->set('permissions', []);
    $role->setIsAdmin(TRUE);
    $role->save();
    $user_settings->clear('admin_role');
    $user_settings->save();
  }
}

/**
 * Updates views to use the entity's field data table, if available.
 */
function head2head_2429447() {
  $entity_manager = \Drupal::entityManager();
  $base_table_mapping = $data_table_fields = [];

  // Collect a base_table -> data_table mapping as well as a list of all fields
  // stored in the data table for all content entity types.
  foreach ($entity_manager->getDefinitions() as $entity_type_id => $entity_type) {
    if (is_subclass_of($entity_type->getClass(), 'Drupal\Core\Entity\ContentEntityInterface')) {
      if ($data_table = $entity_type->getDataTable()) {
        $base_table_mapping[$entity_type->getBaseTable()] = $data_table;
        $data_table_fields[$entity_type_id] = $entity_manager->getStorage($entity_type_id)->getTableMapping()->getFieldNames($data_table);
      }
    }
  }

  $views = $entity_manager->getStorage('view')->loadMultiple();
  foreach ($views as $view) {
    $changed = FALSE;

    // Update the base table name if needed.
    if (isset($base_table_mapping[$view->get('base_table')])) {
      $view->set('base_table', $base_table_mapping[$view->get('base_table')]);
      $changed = TRUE;
    }

    // Iterate over all displays and update the table name.
    foreach (array_keys($view->get('display')) as $display_id) {
      $display = &$view->getDisplay($display_id);
      foreach (\Drupal\views\Views::getHandlerTypes() as $handler_type) {
        $handler_type = $handler_type['plural'];
        if (!isset($display['display_options'][$handler_type])) {
          continue;
        }
        foreach ($display['display_options'][$handler_type] as $id => &$handler_config) {
          if (isset($handler_config['entity_type']) && isset($handler_config['entity_field'])) {
            $handler_entity_type = $handler_config['entity_type'];
            $handler_entity_field = $handler_config['entity_field'];

            if (isset($base_table_mapping[$handler_config['table']]) && isset($data_table_fields[$handler_entity_type][$handler_entity_field])) {
              $handler_config['table'] = $base_table_mapping[$handler_config['table']];
              $changed = TRUE;
            }
          }
          elseif (isset($handler_config['plugin_id']) && $handler_config['plugin_id'] === 'taxonomy_index_tid_depth') {
            // This plugin does not have 'entity_field' set, but still needs its
            // base table updated.
            // @todo Find a more generic way and/or other plugin types that
            //   need this?
            if (isset($base_table_mapping[$handler_config['table']])) {
              $handler_config['table'] = $base_table_mapping[$handler_config['table']];
              $changed = TRUE;
            }
          }
        }
      }
    }

    if ($changed) {
      $view->save();
    }
  }
}

/**
 * Updates default langcode and language overrides for active configuration.
 */
function head2head_2212069() {
  // This is basically a copy of locale_system_set_config_langcodes() with some
  // extra processing for copying any language overrides to the active config
  // and adding an English language override if needed.
  $language_manager = \Drupal::languageManager();
  $default_langcode = $language_manager->getDefaultLanguage()->getId();
  if ($default_langcode != 'en') {
    // Update active configuration copies of all prior shipped configuration if
    // they are still English. It is not enough to change configuration shipped
    // with the components just installed, because installing a component such
    // as views or tour module may bring in default configuration from prior
    // components.
    $names = \Drupal\locale\Locale::config()->getComponentNames();
    foreach ($names as $name) {
      $config = \Drupal::configFactory()->reset($name)->getEditable($name);
      // Should only update if still exists in active configuration. If locale
      // module is enabled later, then some configuration may not exist anymore.
      if (!$config->isNew()) {
        $langcode = $config->get('langcode');
        if (empty($langcode) || $langcode == 'en') {
          // Load the config override in the default langcode so we can copy its
          // data into the main configuration object.
          $override = $language_manager->getLanguageConfigOverride($default_langcode, $name);

          // Only try to merge values if an override actually exists.
          if (!$override->isNew()) {
            $config_data = $config->get();
            $override_data = $override->get();

            // Merge any override data into the main configuration object and
            // delete the override.
            $merged_data = \Drupal\Component\Utility\NestedArray::mergeDeepArray(array($config_data, $override_data), TRUE);
            $config->setData($merged_data, FALSE);
            $override->delete();

            // If any string from the override has been put into the main config
            // object, we need to create an English override containing all the
            // string that were overwritten above.
            if ($english_override_data = \Drupal\Component\Utility\DiffArray::diffAssocRecursive($config_data, $merged_data)) {
              $english_override = $language_manager->getLanguageConfigOverride('en', $name);
              $english_override->setData($english_override_data, FALSE)->save();
            }
          }

          $config->set('langcode', $default_langcode);
          $config->save();
        }
      }
    }
  }
}

/**
 * Updates views to use Field API handlers instead of custom ones.
 */
function head2head_2393339() {
  $names = \Drupal::configFactory()->listAll('views.view.');
  foreach ($names as $name) {

    $view = \Drupal::configFactory()->getEditable($name);
    // Iterate over all displays and update the table name.
    $displays = $view->get('display');
    foreach ($displays as $display_id => &$display) {
      foreach (\Drupal\views\Views::getHandlerTypes() as $handler_type) {
        $handler_type = $handler_type['plural'];
        if (!isset($display['display_options'][$handler_type])) {
          continue;
        }
        foreach ($display['display_options'][$handler_type] as $id => &$handler_config) {
          if (!isset($handler_config['plugin_id'])) {
            continue;
          }
          switch ($handler_config['plugin_id']) {
            // @see https://www.drupal.org/node/2342045
            // @see https://www.drupal.org/node/2455131
            case 'standard':
              $handler_config['plugin_id'] = 'field';
              break;

            // @see https://www.drupal.org/node/2454163
            case 'comment_username':
              $handler_config['plugin_id'] = 'field';
              $handler_config['type'] = 'comment_username';
              unset($handler_config['link_to_user']);
              break;

            // @see https://www.drupal.org/node/2455149
            case 'aggregator_xss':
              $handler_config['plugin_id'] = 'field';
              $handler_config['type'] = 'aggregator_xss';
              break;

            // @see https://www.drupal.org/node/2456691
            case 'user_mail':
              $handler_config['plugin_id'] = 'field';
              $handler_config['type'] = 'basic_string';
              unset($handler_config['link_to_user']);
              break;

            // @see https://www.drupal.org/node/2456599
            case 'node_revision':

            // @see https://www.drupal.org/node/2342045
            case 'numeric':
            case 'node':
            case 'boolean':

            // @see https://www.drupal.org/node/2454171
            case 'node_type':

            // @see https://www.drupal.org/node/2454145
            case 'user_name':
            case 'user':

            // @see https://www.drupal.org/node/2456701
            case 'aggregator_title_link':

            // @see https://www.drupal.org/node/2456705
            case 'comment':

            // @see https://www.drupal.org/node/2456707
            case 'block_content':

            // @see https://www.drupal.org/node/2456709
            case 'file':
            case 'file_uri':
            case 'file_filemime':
            case 'file_extension':
            case 'file_size':
            case 'file_status':

            // @see https://www.drupal.org/node/2456713
            case 'taxonomy':
              // Handle more complex cases with a callback function.
              $function = '_head2head_update_views_field_handler_' . $handler_config['plugin_id'];
              if (function_exists($function)) {
                // We always need to update the plugin_id, so do it here.
                $handler_config['plugin_id'] = 'field';
                $function($handler_config);
              }
              break;
          }
        }
      }
    }

    $view->set('display', $displays);
    $view->save(TRUE);
  }
}

/**
 * Updates the views handler config for the 'numeric' field plugin.
 */
function _head2head_update_views_field_handler_numeric(array &$handler_config) {
  $handler_config['type'] = 'number_integer';

  // 'thousand_separator' is the only setting that we need to migrate.
  if (isset($handler_config['separator']) && $handler_config['separator']) {
    $handler_config['settings']['thousand_separator'] = $handler_config['separator'];
  }

  $keys_to_remove = [
    'set_precision',
    'precision',
    'decimal',
    'separator',
    'format_plural',
    'format_plural_singular',
    'format_plural_string',
    'prefix',
    'suffix',
  ];
  foreach ($keys_to_remove as $key) {
    unset($handler_config[$key]);
  }
}

/**
 * Updates the views handler config for the 'node' field plugin.
 */
function _head2head_update_views_field_handler_node(array &$handler_config) {
  $handler_config['type'] = 'string';

  if (isset($handler_config['link_to_node'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_node'];
    unset($handler_config['link_to_node']);
  }
}

/**
 * Updates the views handler config for the 'boolean' field plugin.
 */
function _head2head_update_views_field_handler_boolean(array &$handler_config) {
  $old_type = isset($handler_config['type']) ? $handler_config['type'] : 'boolean';
  $handler_config['type'] = 'boolean';

  if (isset($handler_config['type_custom_true']) && $handler_config['type_custom_true']) {
    $handler_config['settings']['format_custom_true'] = $handler_config['type_custom_true'];
  }

  if (isset($handler_config['type_custom_false']) && $handler_config['type_custom_false']) {
    $handler_config['settings']['format_custom_false'] = $handler_config['type_custom_false'];
  }

  if ($old_type == 'published-notpublished') {
    $handler_config['settings']['format_custom_true'] = 'Published';
    $handler_config['settings']['format_custom_false'] = 'Unpublished';
  }

  if ($old_type == 'published-notpublished') {
    $handler_config['settings']['format_custom_true'] = 'Active';
    $handler_config['settings']['format_custom_false'] = 'Blocked';
  }
}

/**
 * Updates the views handler config for the 'node_type' field plugin.
 */
function _head2head_update_views_field_handler_node_type(array &$handler_config) {
  $handler_config['type'] = 'entity_reference_label';

  if (isset($handler_config['link_to_node'])) {
    $handler_config['settings']['link'] = $handler_config['link_to_node'];
    unset($handler_config['link_to_node']);
  }

  unset($handler_config['machine_name']);
}

/**
 * Updates the views handler config for the 'user_name' field plugin.
 */
function _head2head_update_views_field_handler_user_name(array &$handler_config) {
  $handler_config['type'] = 'user_name';

  if (isset($handler_config['link_to_user'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_user'];
    unset($handler_config['link_to_user']);
  }

  $keys_to_remove = [
    'overwrite_anonymous',
    'anonymous_text',
    'format_username',
  ];
  foreach ($keys_to_remove as $key) {
    unset($handler_config[$key]);
  }
}

/**
 * Updates the views handler config for the 'user' field plugin.
 */
function _head2head_update_views_field_handler_user(array &$handler_config) {
  $handler_config['type'] = 'user';
  unset($handler_config['link_to_user']);
}

/**
 * Updates the views handler config for the 'node_revision' field plugin.
 */
function _head2head_update_views_field_handler_node_revision(array &$handler_config) {
  $handler_config['type'] = 'string';

  if (isset($handler_config['link_to_node'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_node'];
  }
  unset($handler_config['link_to_node'], $handler_config['link_to_node_revision']);
}

/**
 * Updates the views handler config for the 'aggregator_title_link' field plugin.
 */
function _head2head_update_views_field_handler_aggregator_title_link(array &$handler_config) {
  $handler_config['type'] = 'aggregator_title';

  if (isset($handler_config['display_as_link'])) {
    $handler_config['settings']['display_as_link'] = $handler_config['display_as_link'];
  }
  unset($handler_config['display_as_link']);
}

/**
 * Updates the views handler config for the 'comment' field plugin.
 */
function _head2head_update_views_field_handler_comment(array &$handler_config) {
  $handler_config['type'] = 'string';

  if (isset($handler_config['link_to_comment'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_comment'];
  }
  unset($handler_config['link_to_comment'], $handler_config['link_to_entity']);
}

/**
 * Updates the views handler config for the 'block_content' field plugin.
 */
function _head2head_update_views_field_handler_block_content(array &$handler_config) {
  $handler_config['type'] = 'string';

  if (isset($handler_config['link_to_entity'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_entity'];
    unset($handler_config['link_to_entity']);
  }
}

/**
 * Updates the views handler config for the 'file' field plugin.
 */
function _head2head_update_views_field_handler_file(array &$handler_config) {
  $handler_config['type'] = 'file_link';

  if (isset($handler_config['link_to_file'])) {
    $handler_config['settings']['link_to_file'] = $handler_config['link_to_file'];
    unset($handler_config['link_to_file']);
  }
}

/**
 * Updates the views handler config for the 'file_uri' field plugin.
 */
function _head2head_update_views_field_handler_file_uri(array &$handler_config) {
  $handler_config['type'] = 'file_uri';

  if (isset($handler_config['file_download_path'])) {
    $handler_config['settings']['file_download_path'] = $handler_config['file_download_path'];
    unset($handler_config['file_download_path']);
  }
}

/**
 * Updates the views handler config for the 'file_filemime' field plugin.
 */
function _head2head_update_views_field_handler_file_filemime(array &$handler_config) {
  $handler_config['type'] = 'file_filemime';

  if (isset($handler_config['filemime_image'])) {
    $handler_config['settings']['filemime_image'] = $handler_config['filemime_image'];
    unset($handler_config['filemime_image']);
  }
  unset($handler_config['link_to_file']);
}

/**
 * Updates the views handler config for the 'file_extension' field plugin.
 */
function _head2head_update_views_field_handler_file_extension(array &$handler_config) {
  $handler_config['type'] = 'file_extension';

  if (isset($handler_config['extension_detect_tar'])) {
    $handler_config['settings']['extension_detect_tar'] = $handler_config['extension_detect_tar'];
    unset($handler_config['extension_detect_tar']);
  }
}

/**
 * Updates the views handler config for the 'file_size' field plugin.
 */
function _head2head_update_views_field_handler_file_size(array &$handler_config) {
  $handler_config['type'] = 'file_size';
  unset($handler_config['file_size_display']);
}

/**
 * Updates the views handler config for the 'file_status' field plugin.
 */
function _head2head_update_views_field_handler_file_status(array &$handler_config) {
  $handler_config['type'] = 'boolean';
  $handler_config['settings']['format'] = 'custom';
  $handler_config['settings']['format_custom_false'] = 'Temporary';
  $handler_config['settings']['format_custom_true'] = 'Permanent';
}

/**
 * Updates the views handler config for the 'taxonomy' field plugin.
 */
function _head2head_update_views_field_handler_taxonomy(array &$handler_config) {
  $handler_config['plugin_id'] = 'term_name';
  $handler_config['type'] = 'string';

  if (isset($handler_config['link_to_taxonomy'])) {
    $handler_config['settings']['link_to_entity'] = $handler_config['link_to_taxonomy'];
    unset($handler_config['link_to_taxonomy']);
  }

  if (isset($handler_config['convert_spaces'])) {
    $handler_config['settings']['convert_spaces'] = $handler_config['convert_spaces'];
    unset($handler_config['convert_spaces']);
  }
}

/**
 * Moves fallback image style to the responsive image style entity.
 */
function head2head_2349461() {
  // Nothing to do if the Responsive image module is not installed.
  if (!\Drupal::moduleHandler()->moduleExists('responsive_image')) {
    return;
  }

  $warning = FALSE;
  $fallback_image_styles = [];
  $fields = \Drupal::entityManager()->getStorage('field_config')->loadByProperties(array('field_type' => 'image'));
  foreach ($fields as $field) {
    $properties = [
      'targetEntityType' => $field->getTargetEntityTypeId(),
      'bundle' => $field->getTargetBundle()
    ];
    $entity_displays = \Drupal::entityManager()->getStorage('entity_view_display')->loadByProperties($properties);

    foreach ($entity_displays as $entity_display) {
      if ($component = $entity_display->getComponent($field->getName())) {
        if ($component['type'] == 'responsive_image' && isset($component['settings']['fallback_image_style'])) {
          $responsive_image_style = $component['settings']['responsive_image_style'];
          $fallback_image_style = $component['settings']['fallback_image_style'];

          // We need to emit a warning if a responsive image style would be
          // configured with multiple fallback image styles.
          if (!isset($fallback_image_styles[$responsive_image_style])) {
            $fallback_image_styles[$responsive_image_style] = $fallback_image_style;
          }
          else {
            $warning = TRUE;
          }
        }
      }
    }
  }

  if ($fallback_image_styles) {
    $responsive_image_styles = \Drupal::entityManager()->getStorage('responsive_image_style')->loadMultiple(array_keys($fallback_image_styles));
    /** @var \Drupal\responsive_image\ResponsiveImageStyleInterface $responsive_image_style */
    foreach ($responsive_image_styles as $id => $responsive_image_style) {
      $responsive_image_style->setFallbackImageStyle($fallback_image_styles[$id])->save();
    }
  }

  if ($warning) {
    drupal_set_message(t('Some responsive image styles were not updated with the proper fallback image style because of conflicting entity display configuration.'), 'warning');
  }
}

/**
 * Rebuilds the field map.
 */
function head2head_2482295() {
  $map = array();

  foreach (FieldConfig::loadMultiple() as $field_definition) {
    $entity_type_id = $field_definition->getTargetEntityTypeId();
    $bundle = $field_definition->getTargetBundle();
    $field_name = $field_definition->getName();

    $map[$entity_type_id][$field_name]['type'] = $field_definition->getType();
    $map[$entity_type_id][$field_name]['bundles'][$bundle] = $bundle;
  }

  // Delete the cache entry.
  \Drupal::cache()->delete('entity_field_map');

  // Update the key_value entries for the bundles per entity type.
  foreach ($map as $entity_type_id => $bundle_field_map) {
    \Drupal::keyValue('entity.definitions.bundle_field_map')
      ->set($entity_type_id, $bundle_field_map);
  }
}

/**
 * Update views to use generic entity link plugins.
 */
function head2head_2322949() {
  /** @var \Drupal\views\Entity\View[] $views */
  $views = \Drupal::entityManager()->getStorage('view')->loadMultiple();
  foreach ($views as $view) {
    $changed = FALSE;
    // Loop through all displays.
    foreach (array_keys($view->get('display')) as $display_id) {
      $display = &$view->getDisplay($display_id);
      // Loop through all fields.
      if (!isset($display['display_options']['fields'])) {
        continue;
      }
      foreach ($display['display_options']['fields'] as $field_name => $config) {
        if (!isset($config['entity_type'])) {
          continue;
        }
        $old_plugin = $config['plugin_id'];
        $entity_type = $config['entity_type'];
        if (preg_match("/{$entity_type}_link_(delete|edit|view)/", $old_plugin, $matches)) {
          $display['display_options']['fields'][$field_name]['plugin_id'] = 'entity_link_' . $matches[1];
          $changed = TRUE;
        }
      }
    }

    if ($changed) {
      $view->save();
    }
  }
}

/**
 * Changes varchar to varchar_ascii for issue #1923406.
 */
function head2head_1923406() {
  // Apply the change for all tables defined via hook_schema().
  foreach (array_keys(\Drupal::moduleHandler()->getModuleList()) as $module) {
    $schema = drupal_get_module_schema($module);
    _head2head_1923406_convert_ascii_fields($schema);
  }

  // Dynamic tables (cache database backends).
  $schema = _head2head_get_dynamic_tables();
  _head2head_1923406_convert_ascii_fields($schema);

  // Entity storage definitions.
  $schema = _head2head_1923406_get_entity_tables();
  _head2head_1923406_convert_ascii_fields($schema);
}

/**
 * Converts varchar_ascii fields for the given schema.
 *
 * @param array $schema
 *   A Drupal schema definition array, keyed by table name.
 */
function _head2head_1923406_convert_ascii_fields(array $schema) {
  $connection = Database::getConnection();
  foreach ($schema as $table => $data) {
    foreach ($data['fields'] as $field_name => $field_definition) {
      if ($field_definition['type'] == 'varchar_ascii') {
        $connection->schema()->changeField($table, $field_name, $field_name, $field_definition);
      }
    }
  }
}

/**
 * Retrieves cache backends for update 1923406.
 *
 * @return array of table definitions.
 */
function _head2head_get_dynamic_tables() {
  // If running MySQL, query for all cache bins.
  $connection = Database::getConnection();
  if ($connection->databaseType() === 'mysql') {
    $tables = $connection->query("SHOW TABLES LIKE '" . $connection->tablePrefix() . "cache\_%'")->fetchCol();
    array_walk($tables, function(&$value) use ($connection) {
      // Remove any prefix from the table name.
      $value = str_replace($connection->tablePrefix(), '', $value);
    });
  }
  else {
    // Hard-code bins created by standard install.
    $tables = [
      'cache_bootstrap',
      'cache_config',
      'cache_data',
      'cache_default',
      'cache_discovery',
      'cache_entity',
      'cache_menu',
      'cache_render',
      'cache_toolbar',
    ];
  }
  $backend = new DatabaseBackend($connection, \Drupal::service('cache_tags.invalidator.checksum'), 'default');
  $bin_schema = $backend->schemaDefinition();
  $schema = array_fill_keys($tables, $bin_schema);

  // Cachetags.
  $cachetags = new DatabaseCacheTagsChecksum($connection);
  $schema['cachetags'] = $cachetags->schemaDefinition();

  // Menu tree. The MenuTreeStorage::schemaDefinition() method is protected,
  // hard code known change.
  $schema['menu_tree']['fields']['menu_name'] = [
    'description' => "The menu name. All links with the same menu name (such as 'tools') are part of the same menu.",
    'type' => 'varchar_ascii',
    'length' => 32,
    'not null' => TRUE,
    'default' => '',
  ];

  return $schema;
}

/**
 * Discover all entity storage table columns that should be varchar_ascii.
 *
 * @return array
 *   Drupal schema, keyed by table name.
 */
function _head2head_1923406_get_entity_tables() {
  $schema = [];
  $entity_manager = \Drupal::entityManager();

  // Define schema templates for changed fields.
  $ascii_varchar_fields = ['filemime', 'entity_type', 'shortcut_set', 'comment_type', 'preferred_langcode', 'menu_name', 'content_translation_source', 'preferred_admin_langcode'];

  // Based very closely on the entity manager change list.
  // @see \Drupal\Core\Entity\EntityDefinitionUpdateManager::getChangeList()
  foreach ($entity_manager->getDefinitions() as $entity_type_id => $entity_type) {

    // Entity changes.
    $storage = $entity_manager->getStorage($entity_type_id);
    $original_definitions = $entity_manager->getLastInstalledFieldStorageDefinitions($entity_type_id);
    if ($storage instanceof SqlEntityStorageInterface) {
      $storage_definitions = $entity_manager->getFieldStorageDefinitions($entity_type_id);
      $table_mapping = $storage->getTableMapping($storage_definitions);

      // Field data.
      foreach ($storage_definitions as $field_id => $field_definition) {
        $changed = [];
        $current_field = \Drupal::keyValue('entity.storage_schema.sql')->get($entity_type_id . '.field_schema_data.' . $field_id, []);
        $new_columns = $field_definition->getColumns();

        // Add bundle and langcode for dedicated table storage.
        $separator = '__';
        if ($table_mapping->requiresDedicatedTableStorage($field_definition)) {
          $new_columns += [
            'bundle' => [
              'type' => 'varchar_ascii',
              'length' => 128,
              'not null' => TRUE,
              'default' => '',
              'description' => 'The field instance bundle to which this row belongs, used when deleting a field instance',
            ],
            'langcode' => [
              'type' => 'varchar_ascii',
              'length' => 32,
              'not null' => TRUE,
              'default' => '',
              'description' => 'The language code for this data item.',
            ]
          ];
          $separator = '_';
        }
        elseif (count($new_columns) == 1) {
          // A field in a shared table with a single column uses only the field
          // name as the column name.
          $new_columns = [$field_id => reset($new_columns)];
        }

        foreach ($current_field as $table => $spec) {
          if (isset($spec['fields'])) {
            foreach ($spec['fields'] as $field_name => $field_spec) {
              $column_name = preg_replace('#^(' . $field_id . $separator . ')#', '', $field_name);
              // First fix types that are now natively defined as varchar_ascii.
              if (isset($new_columns[$column_name]) && (($new_columns[$column_name]['type'] === 'varchar_ascii') || !empty($new_columns[$column_name]['is_ascii']))) {
                if (!empty($new_columns[$column_name]['is_ascii'])) {
                  // Still unsure why there are 2 different ways of storing this.
                  $field_spec['is_ascii'] = TRUE;
                }
                else {
                  $field_spec['type'] = 'varchar_ascii';
                }
                $schema[$table]['fields'][$field_name] = $field_spec;
                // The column names in the stored schema are always the actual
                // column names. For base fields with a single column, we
                // mapped it to the actual column name above, map it back here.
                $changed[] = !$table_mapping->requiresDedicatedTableStorage($field_definition) && count($new_columns) == 1 ? $field_definition->getMainPropertyName() : $column_name;
                $current_field[$table]['fields'][$field_name] = $field_spec;
              }
            }
          }
        }

        if (!empty($changed)) {
          // Update stored sql definition.
          \Drupal::keyValue('entity.storage_schema.sql')->set($entity_type_id . '.field_schema_data.' . $field_id, $current_field);
          // Update stored field definition.
          // @todo there must be a better way?!
          $original_field_definition = $original_definitions[$field_id];
          $reflection = new ReflectionObject($original_field_definition);
          $schema_property = $reflection->getProperty('schema');
          $schema_property->setAccessible(TRUE);
          $original_schema = $schema_property->getValue($original_field_definition);
          $new_schema = $field_definition->getSchema();
          foreach (array_unique($changed) as $column_name) {
            if (isset($original_schema['columns'][$column_name])) {
              if ($new_schema['columns'][$column_name]['type'] == 'varchar') {
                // Unsure why these are stored in 2 different ways.
                $original_schema['columns'][$column_name]['is_ascii'] = TRUE;
              }
              else {
                $original_schema['columns'][$column_name]['type'] = 'varchar_ascii';
              }
            }
          }
          $schema_property->setValue($original_field_definition, $original_schema);
          $schema_property->setAccessible(FALSE);
          \Drupal::keyValue('entity.definitions.installed')->set($entity_type_id . '.field_storage_definitions', $original_definitions);
        }
      }
    }
  }

  return $schema;
}

/**
 * Determine if the main property column is varchar_ascii.
 */

/**
 * @param \Drupal\Core\Field\FieldStorageDefinitionInterface $field_storage
 *
 * @return string|bool
 *   Returns FALSE if the column is not ascii, other wise returns 'is_ascii'
 *   for fields that are stored with that, otherwise 'varchar_ascii' for those.
 */
function _head2head_is_varchar_ascii(FieldStorageDefinitionInterface $field_storage) {
  $columns = $field_storage->getColumns();
  $main_property = $field_storage->getMainPropertyName();

  if (!isset($columns[$main_property])) {
    return FALSE;
  }

  if ($columns[$main_property]['type'] === 'varchar_ascii'
    || (($columns[$main_property]['type'] === 'varchar') && !empty($columns[$main_property]['is_ascii']))
  ) {
    return $columns[$main_property]['type'] === 'varchar_ascii' ? 'varchar_ascii' : 'is_ascii';
  }

  return FALSE;
}

/**
 * Add the custom block listing view.
 */
function head2head_2375589() {
  // Only create if the view doesn't exist and views is enabled.
  if (!View::load('block_content') && \Drupal::moduleHandler()->moduleExists('views')) {
    $config_path = drupal_get_path('module', 'block_content') . '/config/optional/views.view.block_content.yml';
    $data = Yaml::parse($config_path);
    \Drupal::configFactory()->getEditable('views.view.block_content')->setData($data)->save(TRUE);
  }
  else {
    drupal_set_message('Not creating views.view.block_content since it already exists.');
  }
}

/**
 * Ensures that system.site:site_front, site_403 and site_404 start with a slash.
 */
function head2head_2509300() {
  /** @var \Drupal\Core\Config\ConfigFactoryInterface $config_factory */
  $config_factory = \Drupal::service('config.factory');
  $config = $config_factory->getEditable('system.site');

  if (($page_front = $config->get('page.front')) && $page_front[0] !== '/') {
    $page_front = '/' . $page_front;
    $config->set('page.front', $page_front);
  }

  if (($page_403 = $config->get('page.403')) && $page_403[0] !== '/') {
    $page_403 = '/' . $page_403;
    $config->set('page.403', $page_403);
  }

  if (($page_404 = $config->get('page.404')) && $page_404[0] !== '/') {
    $page_404 = '/' . $page_404;
    $config->set('page.404', $page_404);
  }

  $config->save();

  // Updates {url_alias} to prepend '/'.
  $query = \Drupal::database()->update('url_alias');

  if (\Drupal::database()->databaseType() !== 'sqlite') {
    $query->expression('source', "concat('/', source)");
    $query->expression('alias', "concat('/', alias)");
  }
  else {
    $query->expression('source', "'/' || source");
    $query->expression('alias', "'/' || alias");
  }

  $query->execute();

  // Update block visibility settings.
  $blocks = \Drupal::entityManager()->getStorage('block')->loadMultiple();
  foreach ($blocks as $block) {
    if (($visibility = $block->get('visibility')) && !empty($visibility['request_path']['pages'])) {
      $pages = preg_split('/\s+/', $visibility['request_path']['pages'], -1, PREG_SPLIT_NO_EMPTY);
      foreach ($pages as $key => $path) {
        // Check this isn't <front> and the path doesn't already start with a /.
        if (($path !== '<front>') && (strpos($path, '/') !== 0)) {
          $pages[$key] = '/' . $path;
        }
      }
      $visibility['request_path']['pages'] = implode("\n", $pages);
      $block->set('visibility', $visibility);
      $block->save();
    }
  }
}

/**
 * Upgrade path for MySQL switch to multibyte UTF8 (issue #1314214).
 */
function head2head_1314214() {
  // The user name field length has changed.
  $schema = \Drupal::keyValue('entity.storage_schema.sql')->get('user.field_schema_data.name');
  $schema['users_field_data']['fields']['name']['length'] = USERNAME_MAX_LENGTH;
  db_change_field('users_field_data', 'name', 'name', $schema['users_field_data']['fields']['name']);
  \Drupal::keyValue('entity.storage_schema.sql')->set('user.field_schema_data.name', $schema);

  // Nothing to do unless this is MySQL.
  if (Database::getConnection()->databaseType() !== 'mysql') {
    return;
  }

  // Process all hook_schema tables.
  foreach (array_keys(\Drupal::moduleHandler()->getModuleList()) as $module) {
    $schema = drupal_get_module_schema($module);
    _head2head_1314214_update_table_collation($schema);
  }

  // Dynamic tables.
  $schema = _head2head_get_dynamic_tables();
  _head2head_1314214_update_table_collation($schema);

  // Entity storage.
  $schema = _head2head_1314214_get_entity_tables();
  _head2head_1314214_update_table_collation($schema);
}

/**
 * Update table collation for given tables.
 *
 * Any indexes will be dropped and re-created so they are the correct length.
 *
 * @param array $schema
 *   Drupal schema array.
 */
function _head2head_1314214_update_table_collation($schema) {
  foreach ($schema as $table => $definition) {
    // Drop any indexes.
    if (isset($definition['indexes'])) {
      foreach ($definition['indexes'] as $index_name => $fields) {
        db_drop_index($table, $index_name);
      }
    }

    Database::getConnection()->query("ALTER TABLE {" . $table . "} COLLATE utf8mb4_general_ci")->execute();

    // Re-create indexes.
    if (isset($definition['indexes'])) {
      foreach ($definition['indexes'] as $index_name => $fields) {
        db_add_index($table, $index_name, $fields, $definition);
      }
    }
  }
}

/**
 * Update for core issue 2498919.
 */
function head2head_2498919() {
  $table_columns = [
    'node_field_data' => ['uid'],
    'node_field_revision' => ['status', 'uid'],
  ];

  foreach ($table_columns as $table => $columns) {
    foreach ($columns as $column) {
      $current_schema = \Drupal::keyValue('entity.storage_schema.sql')->get('node.field_schema_data.' . $column, []);
      $current_schema[$table]['fields'][$column]['not null'] = TRUE;
      db_change_field($table, $column, $column, $current_schema[$table]['fields'][$column]);
      \Drupal::keyValue('entity.storage_schema.sql')->set('node.field_schema_data.' . $column, $current_schema);
    }
  }
}

/**
 * Get entity table schema definitions.
 *
 * @return array
 *   Drupal schema array.
 */
function _head2head_1314214_get_entity_tables() {
  $entity_manager = \Drupal::entityManager();
  $schema = [];
  foreach ($entity_manager->getDefinitions() as $entity_type_id => $entity_type) {
    // Entity changes.
    $storage = $entity_manager->getStorage($entity_type_id);
    if ($storage instanceof SqlEntityStorageInterface) {
      $current_schema = \Drupal::keyValue('entity.storage_schema.sql')->get($entity_type_id . '.entity_schema_data');

      /** @var  $storage \Drupal\Core\Entity\Sql\SqlEntityStorageInterface */
      $table_mapping = $storage->getTableMapping();
      foreach ($table_mapping->getTableNames() as $table) {
        if (isset($current_schema[$table])) {
          $schema[$table] = $current_schema[$table];
        }

        // Need to add index field data.
        _head2head_get_field_schema($entity_type_id, $table, $schema);
      }
    }
  }

  return $schema;
}

/**
 * For a given entity type and table, provide the field schema.
 */
function _head2head_get_field_schema($entity_type_id, $table, &$schema) {
  $entity_manager = \Drupal::entityManager();
  foreach ($entity_manager->getFieldStorageDefinitions($entity_type_id) as $field_name => $field_definition) {
    $current_field = \Drupal::keyValue('entity.storage_schema.sql')->get($entity_type_id . '.field_schema_data.' . $field_name, []);
    if (isset($current_field[$table]['fields'])) {
      if (!isset($schema[$table]['fields'])) {
        $schema[$table]['fields'] = [];
      }
      $schema[$table]['fields'] += $current_field[$table]['fields'];
    }
    if (isset($current_field[$table]['indexes'])) {
      if (!isset($schema[$table]['indexes'])) {
        $schema[$table]['indexes'] = [];
      }
      $schema[$table]['indexes'] += $current_field[$table]['indexes'];
    }
  }
}
